# big O

Created By: Sergey Surganov
Last Edited: Dec 28, 2019 11:31 PM
Tags: Important, Marketing

### big O의 개념

---

- big O시간 = 알고리즘의 효율성을 나타내는 지표 또는 언어

(예) 데이터 전송 알고리즘
O(s) : 파일의 크기가 s일 때, 파일 크기가 증가함에 따라 전송시간이 선형적으로 증가
O(1) : 파일 크기에 상관없이 상수시간 만큼만 소요

### 시간 복잡도

---

- 알고리즘의 수행시간은 **3가지 방법**으로 나타낼 수 있음
    1. 최선의 경우 

        $$O(N)$$

    2. 최악의 경우

        $$O(N^2)$$

    3. 평균의 경우

    $$O(NlogN)$$

### 공간 복잡도

---

- 알고리즘에서는 시간 외에도 **메모리(공간)**을 고려해야 함

- 크기가 n인 배열을 생성 ⇒ O(n)의 공간이 필요
- n x n 크기의 2차원 배열을 생성 ⇒ O(n^2)의 공간 필요

- 재귀 호출에서 사용되는 스택 공간은 공간 복잡도 계산에 사용됨

    int sum(int n) {
    	if (n <= 0){
    		return 0;
    	}
    	return n + sum(n-1);
    }
    
    // sum함수가 호출될 때마다 스택의 깊이가 깊어짐
    // 위의 호출은 전부 호출 스택에 더해지고, 실제 메모리 공간을 잡아 먹음

    int pairSumSequence(int n){
    	int sum=0;
    	for(int i=0; i<n; i++){
    		sum+=pairSum(i, i+1);
    	}
    	return sum;
    }
    
    int pairSum(int a, int b){
    	return a+b;
    }
    
    // pairSum 함수를 대략 O(n)번 호출하지만, 함수들이 호출 스택에 동시에 존재하지 않음
    // O(1) 공간만 사용

### 상수항은 무시하기

---

- 시간 복잡도에서, O(N)이 항상 O(2N)보다 좋은 것은 아니다.

    int min = Integer.MAX_VALUE;
    int max = Integer.Min_VALUE;
    
    //CASE 1
    for(int x : array) {
    	if (x<min) min=x;
    	if (x<max) max=x;
    }
    
    //CASE 2
    for(int x : array) {
    	if (x<min) min=x;
    }
    for(int x : array) {
    	if (x>max) max=x;
    }

### 지배적이지 않은 항은 무시하기

---

$$O(N^2+N) = O(N^2)$$

$$O(N+logN) = O(N)$$

$$O(5*2^N+1000N^100) = O(2^N)$$

### 여러 부분으로 이루어진 알고리즘 : 덧셈, 곱셈

---

- 알고리즘이 두 단계로 이루어질 때, 어떤 경우에 **수행시간을 더하고** 어떤 경우에 **수행시간을 더할까**?

    // 덧셈 수행시간 : O(A+B)
    for (int a : arrA){
    	print(a);
    }
    for (int b : arrB){
    	print(b);
    }
    
    // 곱셈 수행시간 : O(A*B)
    for (int a : arrA){
    	for (int b : arrB){
    		print(a + "," + b);
    	}
    }

A **일을 모두 끝마친 뒤에** B를 수행하라 ⇒ **A + B**
A **일을 할 때 마다**, B 일을 수행하라 ⇒ **A * B**

### 상환시간

---

- **ArrayList (동적 가변크기 배열)**
    - 배열의 역할을 하고, 동시에 크기가 자유롭게 조절되는 자료구조 (배열로 구현됨)
    - 원소 삽입 시 필요에 따라 배열의 크기를 증가시킬 수 있어, 배열의 공간이 바닥날 일은 없음
    - 기존보다 크기가 2배 더 큰 배열을 만든 뒤, 이전 배열의 모든 원소를 새 배열로 복사
- 전체 수행 시간의 계산
    1. 배열이 가득찬 경우(N개), 새로운 원소를 삽입하려면 O(N)시간이 소요
    2. 대다수의 경우에는 배열이 가득 차지 않은 경우로, 이때의 삽입 연산은 O(1) 시간이 소요

    **상환 개념**을 이용하여 계산
    ⇒ 최악의 경우(배열이 가득 찬 경우)는 가끔 발생하지만, 한 번 발생하면 그 후로 꽤 오랫동안 나타나지 않으므로 비용(수행시간)을 분할 상환한다.